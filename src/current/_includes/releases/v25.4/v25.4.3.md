## v25.4.3

Release Date: January 9, 2026

{% include releases/new-release-downloads-docker-image.md release=include.release %}

<h3 id="v25-4-3-operational-changes">Operational changes</h3>

- Successfully completed automatic SQL stats collecton jobs are now automatically purged rather than being retained for the full default job retention period. [#159412][#159412]

<h3 id="v25-4-3-bug-fixes">Bug fixes</h3>

- Fixed a bug where a SQL statement with side effects (e.g., `INSERT`) inside a PL/pgSQL routine could be dropped if it used an `INTO` clause and none of the target variables were referenced. This bug had been present since v23.2. [#158346][#158346]
- Fixed a bug that could cause incorrect query results when using prepared statements with _NULL_ placeholders. The bug has existed since v21.2 and violated SQL _NULL_-equality semantics by returning rows with _NULL_ values when the result set should have been empty. From v21.2 to v25.3, the bug occurred when all of the following were true:
    - The query was run with an explicit or implicit prepared statement
    - The query had an equality filter on a placeholder and a `UNIQUE` column
    - The column contained _NULL_ values
    - The placeholder was assigned to _NULL_ during execution
  - Starting in v25.4, the requirements to trigger the bug were loosened: the column no longer needed to be `UNIQUE`, and the bug could be reproduced if the column was included in any index. [#159062][#159062]
- Fixed a bug where `TRUNCATE` did not behave correctly with respect to the `schema_locked` storage parameter, and was not being blocked when Logical Data Replication (LDR) was in use. This behavior was incorrect and has been fixed. [#159404][#159404]
- Fixed a bug that allowed columns to be dropped despite being referenced by a routine. This could occur when a column was only referenced as a target column in the `SET` clause of an `UPDATE` statement within the routine. This fix only applies to newly-created routines. In versions prior to v26.1, the fix must be enabled by setting the session variable `prevent_update_set_column_drop`. [#159441][#159441]
- Fixed a race condition that could occur during context cancellation of an incoming snapshot. [#159535][#159535]
- Fixed a bug that could cause a panic during changefeed startup if an error occurred while initializing the metrics controller. [#159548][#159548]
- Fixed a memory accounting issue that could occur when a lease expired due to a SQL liveness session-based timeout. [#159622][#159622]
- Fixed an issue where long-running transactions with many statements could cause unbounded memory growth in the SQL statistics subsystem. When a transaction includes a large number of statements, the SQL statistics ingester now automatically flushes buffered statistics before the transaction commits. As a side effect, the flushed statement statistics might not have an associated transaction fingerprint ID because the transaction has not yet completed. In such cases, the transaction fingerprint ID cannot be backfilled after the fact. [#159646][#159646]
- Fixed a bug causing a query predicate to be ignored when the predicate was on a column following one or more `ENUM` columns in an index, the predicate constrained the column to multiple values, and a lookup join to the index was chosen for the query plan. This bug was introduced in 24.3.0 and has been present in all versions since. [#159777][#159777]
- Fixed a race condition where queries run after revoking `BYPASSRLS` could return wrong results because cached plans failed to notice the change immediately. [#160086][#160086]
- Fixed a bug where renaming a column that participated in multiple hash-sharded indexes would fail. [#160087][#160087]
- Fixed a deadlock that could occur when a statistics creation task panicked. [#160584][#160584]

<h3 id="v25-4-3-performance-improvements">Performance improvements</h3>

- `AFTER` triggers now use a cache for descriptor lookups of `TG_TABLE_SCHEMA`, which can significantly reduce trigger planning latency. [#158908][#158908]
- Added a new session variable, `distsql_prevent_partitioning_soft_limited_scans`, which, when true, prevents scans with soft limits from being planned as multiple TableReaders by the physical planner. This should decrease the initial setup costs of some fully-distributed query plans. [#160603][#160603]

[#159646]: https://github.com/cockroachdb/cockroach/pull/159646
[#160086]: https://github.com/cockroachdb/cockroach/pull/160086
[#158908]: https://github.com/cockroachdb/cockroach/pull/158908
[#158346]: https://github.com/cockroachdb/cockroach/pull/158346
[#159535]: https://github.com/cockroachdb/cockroach/pull/159535
[#159622]: https://github.com/cockroachdb/cockroach/pull/159622
[#160087]: https://github.com/cockroachdb/cockroach/pull/160087
[#159412]: https://github.com/cockroachdb/cockroach/pull/159412
[#159777]: https://github.com/cockroachdb/cockroach/pull/159777
[#159441]: https://github.com/cockroachdb/cockroach/pull/159441
[#159062]: https://github.com/cockroachdb/cockroach/pull/159062
[#159404]: https://github.com/cockroachdb/cockroach/pull/159404
[#159548]: https://github.com/cockroachdb/cockroach/pull/159548
[#160584]: https://github.com/cockroachdb/cockroach/pull/160584
[#160603]: https://github.com/cockroachdb/cockroach/pull/160603
