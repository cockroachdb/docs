- `SELECT FOR UPDATE` obtains an *exclusive lock* on each qualifying row, blocking concurrent writes and locking reads on the row. Only one transaction can hold an exclusive lock on a row at a time, and only the transaction holding the exclusive lock can write to the row. {% if page.title == "Read Committed Transactions" %}For an example, see [Reserve rows for updates using exclusive locks](#reserve-rows-for-updates-using-exclusive-locks).{% endif %}

- `SELECT FOR SHARE` obtains a *shared lock* on each qualifying row, blocking concurrent writes and **exclusive** locking reads on the row. Multiple transactions can hold a shared lock on a row at the same time. When multiple transactions hold a shared lock on a row, none can write to the row. A shared lock grants transactions mutual read-only access to a row, and ensures that they read the latest value of the row. {% if page.title == "Read Committed Transactions" %}For an example, see [Reserve values using shared locks](#reserve-row-values-using-shared-locks).{% endif %}

	{{site.data.alerts.callout_info}}
	Shared locks are not enabled by default for `SERIALIZABLE` transactions. To enable shared locks for `SERIALIZABLE` transactions, configure the [`enable_shared_locking_for_serializable` cluster setting]({% link {{ page.version.version }}/cluster-settings.md %}). To perform [foreign key]({% link {{ page.version.version }}/foreign-key.md %}) checks under `SERIALIZABLE` isolation with shared locks, configure the [`enable_implicit_fk_locking_for_serializable` cluster setting]({% link {{ page.version.version }}/cluster-settings.md %}). This matches the default `READ COMMITTED` behavior.
	{{site.data.alerts.end}}

When a `SELECT FOR UPDATE` or `SELECT FOR SHARE` read is issued on a row, only the latest value of the row is returned to the client.