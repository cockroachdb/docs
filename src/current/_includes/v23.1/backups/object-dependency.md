When you back up a table, the backup will include all of its dependent objects, but the backup will not include any dependent tables. For example, if you back up [view]({% link {{ page.version.version }}/views.md %}) `v` that depends on table `t`, it will only back up `v`, not `t`. When you try to restore `v`, the restore will fail because the referenced table is not present in the backup. Alternatively, you can pass [`skip_missing_views`]({% link {{ page.version.version }}/restore.md %}#skip-missing-views) with {% if page.name == "restore.md" %} `RESTORE` {% else %} [`RESTORE`]({% link {{ page.version.version }}/restore.md %}) {% endif %} to skip the view instead. This is also the case for tables or views with [sequences]({% link {{ page.version.version }}/create-sequence.md %}); you can use the [`skip_missing_sequences`]({% link {{ page.version.version }}/restore.md %}#skip-missing-sequences) option with `RESTORE`.

Considering this, restoring individual tables is a good strategy for tables that do not have relationships to other objects. For example, tables that work as append-only logs or outboxes.

We recommend treating tables with [foreign keys]({% link {{ page.version.version }}/foreign-key.md %}), which contribute to [views]({% link {{ page.version.version }}/views.md %}), or that use sequences or user-defined types as a single unit. While you can restore individual tables, you may find that trying to reconstruct the relationships between these different types tedious or error-prone.

As you design your schema, if a database contains some tables that have dependent objects alongside independent tables, you will have greater flexibility by separating them into different databases.